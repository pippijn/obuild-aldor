-------------------------------------------------------------------------
--
-- cs_ccomp.as
--
-------------------------------------------------------------------------

#include "charset.as"

macro AS == AutoreducedSet( PR, RT );

+++\begin{addescription}{decomposes elements into coherent autoreduced sets}
+++ The \adname[DecompositionAlgorithmType]{decompose} functions of \adthistype implement the Coherent-Components algortihm of \cite{Hubert2000}. The parameter \adcode{TRANG} corresponds to the subalgorithm Coherent-Autoreduced of Coherent-Components.
+++
+++If \adcode{T} denotes a differential polynomial ring and \adcode{RT} is a differential reduction, then given a set of differential polynomials $A$, \adthistype computes autoreduced sets $D_i$, such that
+++$$\{A\} = \bigcap_{i=1}^{s} [D_i]:H_{D_i}^\infty,$$
+++where $\{A\}$ denotes the radical of the differential ideal generated by $A$, $[D_i]$ the differential ideal generated by $D_i$, and $H_{D_i}$ the set of initials and separants of $D_i$. $[ D_i ] : H_{D_i}^\infty$ is radical. $D_i$ is coherent, which means $D_i$ reduces every delta polynomial of its elements to $0$. $s$ depends on $A$.
+++\end{addescription}
+++\begin{adremarks}
+++If \adcode{TRANG} has \adtype{UpdatableTriangularizationAlgorithmType}, triangularizations are not computed from scratche every time, but updated wherever this is possible.
+++\end{adremarks}
+++\begin{adseealso}
+++  \adtype{CoherentAutoreducedSetTools}
+++  \adtype{ChiDecompositionTools}
+++  \cite{Hubert2000}
+++\end{adseealso}
CoherentComponentsDecompositionTools( 
  R    : with {
      Field;
      CharacteristicZero;
  },
  VARS : VariableType,
  EXP : ExponentCategory VARS,
  PR   : RankedTriangularizationTType with {
      PolynomialRing0( R, VARS );
  },
  RT: TriangularizationReductionType PR,
  TRANG: TriangularizationAlgorithmType( PR, RT ) == CoherentAutoreducedSetTools( PR, RT, BasicSetSortedTools( PR, RT ) )
) : with {
    DecompositionAlgorithmType( PR, RT );
} == add {

    -------------------------------------------

    ASSURESEPIN( PR, VARS );
    
    -------------------------------------------

    macro DECOMPOSE( Sigma, oldStatus ) == {
	import from PR;
	import from AS;
	import from Set AS;
	empty? Sigma => ( empty, empty );
	local newStatus: Pointer;
	local retPremult: Set PR;	
	local A: AS;
	if TRANG has UpdatableTriangularizationAlgorithmType( PR, RT ) then
	{
	    ( A: AS, retPremult: Set PR, newStatus: Pointer ) := (triangularize$TRANG) ( Sigma, oldStatus );
	} else {
	    ( A: AS, retPremult: Set PR ) := (triangularize$TRANG) ( Sigma );
	}
	contradictory? A => ( empty, empty );

	local retSetAs: Set AS := [ A ];
	local splittings: Set PR := empty;
	for a in A repeat {
	    splittings := union!( splittings, [ assuredSeparant a, assuredInitial a ] );
	}

	for splitting in splittings | ~ ground? splitting repeat 
	{

            if TRANG has UpdatableTriangularizationAlgorithmType( PR, RT ) then
	    {
		( stepSetAs: Set AS, stepPremult: Set PR ) := decompose( insert( splitting, Sigma ), newStatus );
	    } else {
		( stepSetAs: Set AS, stepPremult: Set PR ) := decompose( insert( splitting, Sigma ) );
	    }
	    retSetAs   := union!( retSetAs,   stepSetAs   );
	    retPremult := union!( retPremult, stepPremult );
	}
	( retSetAs, retPremult );
    }

    -------------------------------------------
    
    decompose( Sigma: List PR, status: Pointer ): ( Set AS, Set PR ) == {
	DECOMPOSE( Sigma, status );
    }

    -------------------------------------------
    
    decompose( Sigma: List PR ): ( Set AS, Set PR ) == {
	DECOMPOSE( Sigma, nil$Pointer )
    }

    -------------------------------------------
    
    decompose( genSigma: Generator PR ): ( Set AS, Set PR ) == {
	local Sigma: List PR := [ genSigma ];
	DECOMPOSE( Sigma, nil$Pointer )
    }

    -------------------------------------------
    
}
