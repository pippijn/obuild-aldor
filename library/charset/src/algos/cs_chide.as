-------------------------------------------------------------------------
--
-- cs_prtrs.as
--
-------------------------------------------------------------------------

#include "charset.as"

macro AS == AutoreducedSet( PR, RT );
macro EXTAS == AutoreducedSet( EXTPR, EXTRT );

+++\begin{addescription}{computes a characteristic decomposition}
+++For the description of \adthistype, let \adcode{PR} denote a differential polynomial ring and \adcode{RT} differential polynomial reduction. Although this setting is not mandatory, it allows to describe the domain better.
+++
+++\adthistype applies the $\chi$-Decomposition of \cite{Hubert2000} to a set $A$ of differential polynomials in the polynomial ring \adcode{PR}.  the \adname{decompose} functions of \adthistype give autoreduced sets $C_i$, such that
+++$$\{A\} = \bigcap_{i=1}^{r} [C_i]:H_{C_i}^\infty,$$
+++where $\{A\}$ denotes the radical of the differential ideal generated by $A$, $[C_i]$ the differential ideal generated by $C_i$, and $H_{C_i}$ the set of initials and separants of $C_i$. $r$ depends on $A$.
+++
+++\adcode{COHERENTCOMPONENTSDECOMP} is used by the algorithm to compute coherent components. Given a set $B$ of differential polynomials, \adcode{COHERENTCOMPONENTSDECOMP} has to compute \emph{coherent} autoreduced sets $D_i$, such that
+++$$\{B\} = \bigcap_{i=1}^{s} [D_i]:H_{D_i}^\infty,$$
+++where $s$ depends on $B$. For each $i$, $[ D_i ] : H_{D_i}^\infty$ has to be radical and $D_i$ has to be coherent, which means $D_i$ reduces every delta polynomial of its elements to $0$.
+++\end{addescription}
+++\begin{adremarks}
+++In \cite{Hubert2000}, the algorithm $0$D-Irredundant-$\chi$-Decomposition can be identified as parameter to the $\chi$-Decomposition algorithm. It is possible to model this additional parameter in \Aldor. However, the \Aldor compiler fails to compile \adthistype with such a parameter (at least with the compiler in version $1.0.2$, which has been used when developping \adthistype). Therefore, there is no parameter to specify an implementation of $0$D-Irredundant-$\chi$-Decomposition. \adthistype uses \adtype{ZeroDimensionalChiDecompositionTools} to perform $0$D-Irredundant-$\chi$-Decomposition.
+++\end{adremarks}
+++\begin{adseealso}
+++  \adtype{CoherentComponentsDecompositionTools}
+++  \adtype{ZeroDimensionalChiDecompositionTools}
+++  \cite{Hubert2000}
+++\end{adseealso}
ChiDecompositionTools( 
  R    : with {
      Field;
      CharacteristicZero;
  },
  VARS : VariableType,
  EXP : ExponentCategory VARS,
  PR   : RankedTriangularizationTType with {
      PolynomialRing0( R, VARS );
      IndexedFreeModule( R, EXP )
  },
  RT: TriangularizationReductionType PR,
  COHERENTCOMPONENTSDECOMP: DecompositionAlgorithmType( PR, RT ) == CoherentComponentsDecompositionTools( R, VARS, EXP, PR, RT )
) : with {

    DecompositionAlgorithmType( PR, RT );

} == add {

    CPR   == DistributivePolynomialRingCommutativeRingExtension( R, VARS, EXP, PR );
    IPR   == DistributivePolynomialRingIntegralDomainExtension( R, VARS, EXP, CPR );
    IPRRT == PseudoRemainderReductionTools( R, VARS, IPR );
    GCDPR == DistributivePolynomialRingSubResultantPRSGcdDomainExtension( R, VARS, EXP, IPR, IPRRT );
    lift: PR -> GCDPR == ( a: PR ): GCDPR +-> {
	import from CPR;
	import from IPR;
	import from GCDPR;
	a::CPR::IPR::GCDPR;
    };
    pullback: GCDPR -> PR == ( a: GCDPR ): PR +-> {
	import from CPR;
	import from IPR;
	import from GCDPR;
	a::IPR::CPR::PR;
    };

    -------------------------------------------

    ASSURESEPIN( PR, VARS );

    -------------------------------------------

    intersectionSimplifyer( input: Set AS ): Set AS == {
	import from MachineInteger;
	import from PR;
	import from R;
	import from RT;
	import from AS;

	local slots := # input;
	local slotIdxs: IntegerSegment MachineInteger := firstIndex$(Array Boolean) .. firstIndex$(Array Boolean) + prev slots;
	
	local inputArray: Array AS := [ generator input ];
	local keepAs?: Array Boolean := new( slots, true );
	
	for primarySlot in slotIdxs repeat 
	{
	    local reductionFunction: PR -> PR := reduceBy( inputArray . primarySlot );
	    while keepAs? . primarySlot for secondarySlot in slotIdxs | primarySlot ~= secondarySlot repeat 
	    {
		if keepAs? . secondarySlot then 
		{
		    local reducedProperly? := true;
		    for secondaryElement in inputArray . secondarySlot while reducedProperly? repeat 
		    {
			reducedProperly? := zero? reductionFunction secondaryElement 
			and ~ zero? reductionFunction assuredInitial  secondaryElement 
			and ~ zero? reductionFunction assuredSeparant secondaryElement ;
		    }
		    keepAs? . primarySlot := ~ reducedProperly?
		}
	    }
	}
	
	[ inputArray . slot for slot in slotIdxs | keepAs? . slot ]
	
    }

    -------------------------------------------
    
    performChiDecomposition(
      EXTR    : with {
	  Field;
	  CharacteristicZero;
	  denominator: % -> GCDPR;
	  numerator: % -> GCDPR;
	  coerce: GCDPR -> %;
      },
      EXTVARS : FiniteVariableType,
      EXTEXP : ExponentCategory EXTVARS,
      EXTPR   : RankedTriangularizationTType with {
	  PolynomialRing0( EXTR, EXTVARS );
	  IndexedFreeModule( EXTR, EXTEXP );
      },
      EXTRT: TriangularizationReductionType EXTPR,
      elementFractA: AS,
      leader: Array VARS
    ): ( Set AS, Set PR ) == {
	SRGBALG == SaturatedGroebnerBasisWrtPolynomialReductionTools( EXTR, EXTVARS, EXTEXP, EXTPR, EXTRT );
	ZERODCHIDECOMP == ZeroDimensionalChiDecompositionTools( EXTR, EXTVARS, EXTEXP, EXTPR, EXTRT, SRGBALG );
	
	import from List EXTVARS;

	-- no sorting on extLeader is necessary, since [ generator minToMax ]
	-- already gives the desired order
	local extLeader: Array EXTVARS := [ generator (minToMax$EXTVARS) ];

	-- Lifing the leaders to indeterminates in a new
	-- domain and non-leaders to the coefficients

	import from EXP;	
	import from PR;	
	import from GCDPR;	
	import from EXTR;	
	import from EXTEXP;	
	import from List EXTPR;	
	import from EXTAS;	
	import from Set EXTAS;
	local extElementAList: DoubleEndedList EXTPR := empty();
	local extElementASaturation: Set EXTPR := empty;
	local extPoly : EXTPR;


	macro migrateGCDPRtoEXTPR( FROM, TO ) == {
	    TO := 0;
	    for monomialFromPR in terms FROM repeat
	    {
		( r: R, e: EXP ) := monomialFromPR;
		extELst: List Cross ( EXTVARS, Integer ) := empty;
		eLst: List Cross ( VARS, Integer ) := empty;
		for partE in terms e repeat 
		{
		    ( varPartE, powerPartE ) := partE ;
		    ( isLeader?, leaderIdx ) := binarySearch( varPartE, leader );
		    if isLeader? then
		    {
			extELst := insert!( ( extLeader . leaderIdx, powerPartE ), extELst );
		    } else {
			eLst := insert!( ( varPartE, powerPartE ), eLst );
		    }
		}
		TO := add!( TO, term( term( r, exponent generator eLst ) :: EXTR, exponent generator extELst ) );
	    }
	}

	for elementElementFractA in elementFractA repeat 
	{
	    migrateGCDPRtoEXTPR( lift elementElementFractA, extPoly );
	    extElementAList := concat!( extElementAList, extPoly );

	    migrateGCDPRtoEXTPR( lift assuredInitial elementElementFractA, extPoly );
	    extElementASaturation := insert!( extPoly, extElementASaturation );

	    migrateGCDPRtoEXTPR( lift assuredSeparant elementElementFractA, extPoly );
	    extElementASaturation := insert!( extPoly, extElementASaturation );

	}

        -- calulate 0Dimensional Decomposition in new Domain

	local extPremult: Set EXTPR;
        local C: Set EXTAS;
	( C, extPremult ) := (decompose$ZERODCHIDECOMP) ( firstCell extElementAList, extElementASaturation );
	
        -- transforming back + adding

	local coeffsEXTPR: List EXTR;
	local commonDenominator: GCDPR;
	local numeratorContent:  GCDPR;
	local pDivResultGCDPR: Partial GCDPR;
	macro migrateEXTPRtoGCDPR( FROM, TO ) == {
	    TO := 0;
	    if ~ zero? FROM then
	    {
		coeffsEXTPR       := [ nonZeroCoefficients FROM ];
		commonDenominator := denominator first coeffsEXTPR;
		numeratorContent  := numerator   first coeffsEXTPR;
		for coeffEXTPR in rest coeffsEXTPR repeat
		{
		    commonDenominator := lcm( commonDenominator, denominator coeffEXTPR );
		    numeratorContent  := gcd( numeratorContent , numerator   coeffEXTPR );
		}
		for monomialFromEXTPR in terms FROM repeat
		{
		    ( extR, extE: EXTEXP ) := monomialFromEXTPR;
		    eLst: List Cross ( VARS, Integer ) := empty;
		    for partExtE in terms extE repeat 
		    {
			( varPartExtE, powerPartExtE ) := partExtE ;
			( isLeader?, leaderIdx ) := binarySearch( varPartExtE, extLeader );
			assert isLeader?;
			eLst := insert!( ( leader . leaderIdx, powerPartExtE ), eLst );
		    }

                    --normalizing the cofficient
		    pDivResultGCDPR := exactQuotient( commonDenominator, denominator extR );
		    assert ~ failed? pDivResultGCDPR;
		    pDivResultGCDPR := exactQuotient( numerator extR * retract pDivResultGCDPR, numeratorContent );
		    assert ~ failed? pDivResultGCDPR;
		    TO := add!( TO, retract pDivResultGCDPR * term( 1$R, exponent generator eLst ) );
		}
	    }
	}

	local result: Set AS := empty;
	local poly  : GCDPR;

	for elementC in C repeat
	{
	    local elementCList: List PR := empty;
	    for elementElementC in elementC repeat
	    {
                migrateEXTPRtoGCDPR( elementElementC, poly );
		elementCList := insert!( pullback poly, elementCList );
	    }
	    import from Partial AS;
	    assert ~ failed? [ generator elementCList ];
	    result := union!( result, retract [ generator elementCList ] );		    
	}
	local premult: Set PR := empty;
	for elementExtPremult in extPremult repeat
	{ -- Wie sollen die Elemente zurückgebracht werden?	    
	}
	( result, premult );
    }


    -------------------------------------------

     macro DECOMPOSE( Sigma ) == {
	import from PR;
	import from AS;

	local fractA: Set AS;
	local premult: Set PR;
	( fractA, premult ) := (decompose$COHERENTCOMPONENTSDECOMP) Sigma;	

	local fractC: Set AS := empty;

	for elementFractA in fractA | ~ contradictory? elementFractA repeat
	{
	    local C: Set AS;
	    local Cpremult: Set PR;
	    -- 1. building up a new polynomial domain

	    -- storing the distinct leaders as array
	    local leaderSet: Set VARS := [ mainVariable elementElementFractA for elementElementFractA in elementFractA ];
	    local leader: Array VARS := sort! [ generator leaderSet ];

	    import from Set PR;
	    import from Integer;
	    import from MachineInteger;
	    -- COMBVARS are not needed, but EXTVARS are the variables in the new domain
	    ( EXTVARS: FiniteVariableType , COMBVARS: MergedVariableType( VARS, EXTVARS ) ) == ((extension$VariableMergerTools)( VARS, coerce # leader ));
	    EXTEXP: ExponentCategory EXTVARS == SortedListExponent EXTVARS;
	    EXTR  == Fraction GCDPR;
	    EXTPR  == DistributivePolynomialRingLeadingTermOrderExtension( EXTR, EXTVARS, EXTEXP, DistributedMultivariatePolynomial1( EXTR, EXTVARS, EXTEXP ) );
	    EXTRT  == PolynomialReductionWithoutDivisionTools( EXTR, EXTVARS, EXTEXP, EXTPR );		
	    -- 2. performing the decomposition
	    -- due to compiler issues, this is done in a separate function, 
	    --which is passed the relevant domains
1$Integer;
	    ( C, Cpremult ) := performChiDecomposition(
	      EXTR, EXTVARS, EXTEXP, EXTPR, EXTRT,
	      elementFractA, leader 
	    );
	    fractC  := union!( fractC , C );
	    premult := union!( premult, Cpremult );
	}
	( intersectionSimplifyer fractC, premult );
    }

    -------------------------------------------
    
    decompose( Sigma: Generator PR ): ( Set AS, Set PR ) == {
	DECOMPOSE( Sigma );
    }

    -------------------------------------------
    
    decompose( Sigma: List PR ): ( Set AS, Set PR ) == {
	DECOMPOSE( Sigma );
    }

    -------------------------------------------
    
}
