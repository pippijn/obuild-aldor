-------------------------------------------------------------------------
--
-- cs_zdchi.as
--
-------------------------------------------------------------------------

#include "charset.as"

macro AS == AutoreducedSet( PR, RT );

+++\begin{addescription}{decomposes zero dimensional, radical ideals}
+++The \adname[SaturatedDecompositionAlgorithmType]{decompose} functions of \adthistype implement the $0$D-Irredundant-$\chi$-Decomposition algortihm of \cite{Hubert2000}.
+++\adcode{PR} denotes the domain for the elements of the saturated ideals to decompose. 
+++
+++The \adname[SaturatedDecompositionAlgorithmType]{decompose} function of \adthistype compute a decomposition of the given ideal $A$ , into $C_1, C_2, \ldots C_r$ such that
+++$$ A = (C_1):I_{C_1}^\infty \cap (C_2):I_{C_2}^\infty \cap  \cdots \cap (C_r):I_{C_r}^\infty$$
+++and
+++$$\forall j,k \in \{1,2,\ldots, r\}: j \ne k \implies (C_j):I_{C_j}^\infty + (C_k):I_{C_k}^\infty = {\tt PR},$$
+++where $C_i$ denotes the ideal generated by $C_i$ and $I_{C_i}$ denotes the set of initials of $C_i$. The ideal $( C_i ) : I_{C_i}^\infty$ is radical and zero dimensional. $C_i$ is a characteristic set of $( C_i ) : I_{C_i}^\infty$.
+++\end{addescription}
+++\begin{adseealso}
+++  \adtype{CoherentAutoreducedSetTools}
+++  \adtype{ChiDecompositionTools}
+++  \cite{Hubert2000}
+++\end{adseealso}
ZeroDimensionalChiDecompositionTools(
  R    : with {
      Field;
      CharacteristicZero;
  },
  VARS : FiniteVariableType,
  EXP : ExponentCategory VARS,
  PR   : RankedTriangularizationTType with {
      PolynomialRing0( R, VARS );
      IndexedFreeModule( R, EXP );
  },
  RT: TriangularizationReductionType PR,
  SRGBALG: SaturatedReducedGroebnerBasisAlgorithmType( PR, RT ) == SaturatedGroebnerBasisWrtPolynomialReductionTools( R, VARS, EXP, PR, RT )
) : with {

   SaturatedDecompositionAlgorithmType( PR, RT );

} == add {

    ASSURESEPIN( PR, VARS );
    
    -------------------------------------------

    macro DECOMPOSE( J, sat ) == {

	import from PR;
	empty? J => ( empty, empty );
	assert (>=$MachineInteger) (# J, #$VARS);

	( G: AS, premultG: Set PR ) := (triangularize$SRGBALG) ( J, sat );
	contradictory? G => ( empty, empty );
	
	(=$MachineInteger) ( # G, #$VARS ) => ( [ G ], premultG );

	for g in G repeat 
	{
	    init := {		
		-- ground? g cannot hold, since G is not contradictory
                assert ~ ground? g;

		local mainVariableG := mainVariable g;
		coefficient( g, mainVariableG, degree( g, mainVariableG ) );
	    };
	    
	    if ~ ground? init then
	    {
		( retAS1: Set AS, premult1: Set PR ) := decompose( insert( init, J ), sat );
		( retAS2: Set AS, premult2: Set PR ) := decompose( J, insert( init, sat ) );
		
		return ( union!( retAS1 , retAS2 ), union!( premultG, union!( premult1, premult2 ) ) );
	    }
	}
	never;
    }

    -------------------------------------------

    decompose( a: List PR ): ( Set AS, Set PR ) == {
	DECOMPOSE( a, empty );
    }

    -------------------------------------------

    decompose( genA: Generator PR ): ( Set AS, Set PR ) == {
	local a: List PR := [ genA ];
	DECOMPOSE( a, empty );
    }

    -------------------------------------------

    decompose( a: List PR, sats: Set PR ): ( Set AS, Set PR ) == {
	DECOMPOSE( a, sats );
    }

    -------------------------------------------

    decompose( genA: Generator PR, genSats: Generator PR ): ( Set AS, Set PR ) == {
	local a: List PR := [ genA ];
	local sats: Set PR := [ genSats ];
	DECOMPOSE( a, sats );
    }

    -------------------------------------------

}
