-------------------------------------------------------------------------
--
-- cs_dvoeo.as
--
-------------------------------------------------------------------------

#include "charset.as"

macro OrderSpec == Cross( DifferentialVariableOrderToolsType, Integer );

+++\begin{addescription}{applies different orders to different classes of indeterminates}
+++\adcode{OrderSpec} is used to specify which order has to be apllied to how many classes of indeterminates. The \adtype{DifferentialVariableOrderToolsType} gives the order and \admacro{Integer} denotes the number of classes, which has to be non negative. For those classes, that are not described by an \adcode{OrderSpec}, \adtype{DifferentialVariableLexicographicEliminationOrderTools} is used. Consider the differential indeterminates generated by seven different indeterminates ($y_1, y_2, \ldots, y_7$) and the derivations $s$ and $t$. Then, 
+++\begin{adsnippet}
+++DifferentialVariableMixedOrderTools([
+++  ( DifferentialVariableOrderlyOrderTools , 2 ),
+++  ( DifferentialVariableLexicographicOrderTools , 3 )
+++])
+++\end{adsnippet}
+++orders $y_1$, $y_2$, and their corresponding derivatives according to \adtype{DifferentialVariableOrderlyOrderTools}. $y_3$, $y_4$, $y_5$, and their corresponding derivatives are ordered by \adtype{DifferentialVariableLexicographicOrderTools}. Since the given \adcode{OrderSpec}s only define orderings for five classes, the remaining indeterminates ($y_6$, $y_7$, and the corresponding derivatives) are ordered by \adtype{DifferentialVariableLexicographicEliminationOrderTools}.
+++\end{addescription}
DifferentialVariableMixedOrderTools(
  ORDERS: List OrderSpec
) : with {

    DifferentialVariableOrderToolsType;

} == add {

    ---------------------------------------------
    
    getComparisonFunc( 
      VARS   : FiniteVariableType, 
      DVARS  : DifferentialVariableType( VARS ),
      ORDER  : DifferentialVariableOrderToolsType
    ): ( DVARS, DVARS ) -> Boolean == {
	(<$ORDER)( VARS, DVARS );
    }

    
    ---------------------------------------------
    
    
    <( VARS   : FiniteVariableType, DVARS  : DifferentialVariableType( VARS ) ): ( DVARS, DVARS ) -> Boolean == {
	import from MachineInteger;
        -- the following array holds comparsion functions for the different orders
	local compFuncs: Array ( ( DVARS, DVARS ) -> Boolean ) := new next (#$VARS);
	local currentCompFuncsIdx := (firstIndex$(Array (( DVARS, DVARS ) -> Boolean)));
	
	-- the following array is used to determine the index in the array 'compFuncs'
	-- for a variable.
	local orderIdxs: Array MachineInteger := new (#$VARS, (firstIndex$(Array (( DVARS, DVARS ) -> Boolean))) + (#$VARS));
	local currentOrderIdxsIdx := firstIndex$( Array MachineInteger );
	local classToIdxsIdx := - next currentOrderIdxsIdx;

	
	--processORDERS
	for elementORDERS in ORDERS repeat {
	    ( orderElementORDERS: DifferentialVariableOrderToolsType, countElementORDERS: Integer ) := elementORDERS;
	    assert( countElementORDERS >= 0);
	    if ~ zero? countElementORDERS then
	    {
		assert( currentCompFuncsIdx <= (firstIndex$(Array (( DVARS, DVARS ) -> Boolean))) + prev (#$VARS) );
		compFuncs . currentCompFuncsIdx := getComparisonFunc( VARS, DVARS,  orderElementORDERS );
		for i in 1 .. countElementORDERS repeat {
		    assert( currentOrderIdxsIdx <= firstIndex$( Array MachineInteger ) + prev (#$VARS) );
		    orderIdxs . currentOrderIdxsIdx := currentCompFuncsIdx;
		    currentOrderIdxsIdx := next currentOrderIdxsIdx;
		}
		currentCompFuncsIdx := next currentCompFuncsIdx;
	    }
	}
	
	-- add fallback order, if not all variables are passed an order explicitely
	compFuncs . ((firstIndex$(Array (( DVARS, DVARS ) -> Boolean))) + (#$VARS)) := getComparisonFunc( VARS, DVARS,  DifferentialVariableLexicographicEliminationOrderTools );
		
	( left: DVARS, right: DVARS ): Boolean +-> {
	    import from Integer;

	    local compIdxLeft  := orderIdxs . ( add!( machine class left , classToIdxsIdx ) );
	    local compIdxRight := orderIdxs . ( add!( machine class right, classToIdxsIdx ) );
	    compIdxLeft = compIdxRight => ( compFuncs .  compIdxLeft )( left, right );	    
	    compIdxLeft < compIdxRight;
	 }   
    }

    
    ---------------------------------------------

    
};
