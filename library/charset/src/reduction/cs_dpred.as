-------------------------------------------------------------------------
--
-- cs_dpred.as
--
-------------------------------------------------------------------------

#include "charset.as"

macro AS == AutoreducedSet( DPR, % );

#assert GCDVERSION

+++\begin{addescription}{implements differential polynomial reduction}
+++For the description of differential polynomial reduction, let $p, q, \text{ and } r$ be elements of \adcode{DPR}. $p$ \emph{is reduced with respect to} $q$ if and only if 
+++\begin{itemize}
+++\item $q$ is zero,
+++\item $q$ is a non zero constant and $p$ is zero, or
+++\item $q$ is not a constant and $p$ contains no proper derivative of the leader of $q$ and the leader of $q$ occurs with a smaller degree in $p$ than in $q$.
+++\end{itemize}
+++
+++If $q$ \emph{reduces} $p$ to $r$, one of the following conditions has to hold.
+++\begin{itemize}
+++\item $q$ is zero and $p$ = $r$.
+++\item $q$ is a non zero constant and $r$ is zero.
+++\item $q$ is not a constant, $r$ is reduced with respect to $q$ and there have to be integers $k$ and $l$ such that
+++$$i_q^k s_q^l p = r \text{ mod } [ q ],$$
+++where $i_q$ denotes the initial of $q$, $s_q$ denotes the separant of $q$ and $[ q ]$ denotes the differential ideal generated by $q$.
+++\end{itemize}
+++
+++\adcode{consequences( p, q )} computes the $\Delta$-polynomial of $p$ and $q$. The $\Delta$-polynomial of $p$ and $q$ is $0$ if $p$, $q$, or both are constants. Furthermore, the $\Delta$-polynomial is $0$ if the main indeterminate of $p$ and the main indeterminate of $q$ have no common derivative. Otherwise, let $\psi, \phi$ be elements in the monoid generated by the derivaitions, such that the least common derivative of the main indeterminates of $p$ and $q$ can be expressed as $\psi$ applied to the main indeterminate of $p$ and also via $\phi$ applied to the main indeterminate of $q$. Then, the $\Delta$-polynomial is $$\text{sep}(q)\psi(p) - \text{sep}(p)\phi(q),$$ where sep denotes the separant of its parameter.
+++\end{addescription}
DifferentialPolynomialReductionTools(
  DFLD  : with{ Field; DifferentialType; CharacteristicZero; },
  VARS  : FiniteVariableType,
  DVARS : DifferentialVariableType( VARS ),
  DPR   : DifferentialPolynomialRingType( DFLD, VARS, DVARS )
) : with {

    TriangularizationReductionType DPR;

    +++\begin{addescription}{performs a part of differential reduction}
    +++For the description of \adthisname, we consider the statement
    +++\begin{adsnippet}
    +++( r, pre ) := reduceStep(q)(p)
    +++\end{adsnippet}
    +++\adcode{r}, \adcode{p}, and \adcode{q} denote elements of \adcode{DPR}, \adcode{pre} denotes a \adtype{Set} of \adcode{DPR}.
    +++\adcode{pre} will hold the elements used to premultiply during the computation.
    +++If \adcode{q} is zero, \adcode{r} is set to \adcode{p} and \adcode{pre} to \adcode{empty}. 
    +++If \adcode{q} is a non-zero constant, \adcode{r} is set to zero and \adcode{pre} to $\{-\frac{p}{q}\}$.
    +++If \adcode{q} is not a constant, \adcode{r} has lower rank than \adcode{p} with respect to the leader of \adcode{q} and there are integers $k$ and $l$ such that
    +++$$i_q^k s_q^l p = r \text{ mod } [ q ],$$
    +++where $i_q$ denotes the initial of $q$, $s_q$ denotes the separant of $q$ and $[ q ]$ denotes the differential ideal generated by $q$.
    +++However, \adcode{r} is not necessarily reduced mith respect to \adcode{q}.
    +++\adcode{pre} is set to $\{a,b\}$, where $a$ and $b$ are of \adcode{DPR} such that $ap + bq = r$.
    +++\end{addescription}
    +++\begin{adremarks}
    +++Applying the function \adcode{reduceStep(q)} to \adcode{p} and then again to the result of this reduction step and so on, finally gives a \adcode{DPR} being reduced with respect to \adcode{q}.
    +++\end{adremarks}
    reduceStep: DPR -> DPR -> ( DPR, Set DPR );

    +++\begin{addescription}{performs a part of differential reduction}
    +++For the description of \adthisname, we consider the statement
    +++\begin{adsnippet}
    +++r := reduceStep(q)(p)
    +++\end{adsnippet}
    +++\adcode{r}, \adcode{p}, and \adcode{q} denote elements of \adcode{DPR}.
    +++If \adcode{q} is zero, \adcode{r} is set to \adcode{p} and \adcode{pre} to \adcode{empty}. 
    +++If \adcode{q} is a non-zero constant, \adcode{r} is set to zero and \adcode{pre} to $\{-\frac{p}{q}\}$.
    +++If \adcode{q} is not a constant, \adcode{r} has lower rank than \adcode{p} with respect to the leader of \adcode{q} and there are integers $k$ and $l$ such that
    +++$$i_q^k s_q^l p = r \text{ mod } [ q ],$$
    +++where $i_q$ denotes the initial of $q$, $s_q$ denotes the separant of $q$ and $[ q ]$ denotes the differential ideal generated by $q$.
    +++However, \adcode{r} is not necessarily reduced mith respect to \adcode{q}.
    +++\end{addescription}
    +++\begin{adremarks}
    +++Applying the function \adcode{reduceStep(q)} to \adcode{p} and then again to the result of this reduction step and so on, finally gives a \adcode{DPR} being reduced with respect to \adcode{q}.
    +++\end{adremarks}
    reduceStep: DPR -> DPR -> DPR;

} == add {

    reducedBy?( b:DPR ): DPR -> Boolean == {
	import from DVARS;
	import from List DVARS;
	import from Integer;


	zero? b => ( a: DPR ): Boolean +-> { true; };
	ground? b => ( a: DPR ): Boolean +-> { zero? a; };

	local mainVariableB := mainVariable b;
	local degreeMainVariableB := degree( b, mainVariable b );

	return (
	  ( a: DPR ): Boolean +-> {
	      ground? a => true;
	      assert( not ground? a );

	      for variableA in variables a repeat
	      {
		  if properDerivative?( variableA, mainVariableB ) or (variableA = mainVariableB and degree( a, variableA ) >= degreeMainVariableB ) then 
		  {
		      return false;
		  } else if variableA < mainVariableB then {
		      return true;
		  }

	      }

	      true;
	  }
	)

    }

    -------------------------------------------


    reduceBy( b: DPR ): DPR -> ( DPR, Set DPR ) == {

	local reducedBy?Function := reducedBy? b;
	local reductionFunction: DPR -> ( DPR, Set DPR ) := reduceStep b;

	return (
	  ( a: DPR ): ( DPR, Set DPR ) +-> {
	      local resultPoly := copy a;
	      local resultSat : Set DPR := empty;

	      while ~ reducedBy?Function resultPoly repeat
	      {
		  local stepSat : Set DPR;
		  ( resultPoly, stepSat ) := reductionFunction resultPoly;
		  resultSat := union!( resultSat, stepSat );

	      }
	      ( resultPoly, resultSat );
	  }
	)
    }


    -------------------------------------------


    reduceStep( b: DPR ): DPR -> DPR == {
	local reductionFunction : DPR -> ( DPR, Set DPR ) := reduceStep b;

	return (
	  ( a: DPR ): DPR +-> {
	      ( red: DPR, sat: Set DPR ) := reductionFunction a;
	      red;
	  }
	)

    }


    -------------------------------------------

    if DPR has GcdDomain then
    {	
	reduceStep( b: DPR ): DPR -> ( DPR, Set DPR ) == {
	    zero? b => ( a: DPR ): ( DPR, Set DPR ) +-> { ( a, empty ); };
	    ground? b => (
	      import from DFLD;
	      invB := inv leadingCoefficient b;
	      ( a: DPR ): ( DPR, Set DPR ) +-> { 
		  zero? a => ( 0, empty );
		  ( 0, [ - invB*a ] );
	      }

	    );

	    import from Integer;
	    import from MachineInteger;
	    import from List DVARS;
	    import from DVARS;
	    assert( ~ ground? b );
	    local mainVariableB := mainVariable b;
	    local orderB := order mainVariableB;
	    local degreeMainVariableB := degree( b, mainVariable b );
	    local mainVariableBWithDegree := term( 1$DFLD, mainVariableB, degreeMainVariableB );
	    local divideByMainVariableBWithDegreeFunc := quotientBy( mainVariableB, degreeMainVariableB );
	    local separantB := separant b;
	    local initialB := initial b;

      	    assert( 0$Integer <= (derivationSymbolsCount$DVARS) );
      	    assert( (derivationSymbolsCount$DVARS) <= max$MachineInteger::Integer);
	    local orderSegment: IntegerSegment MachineInteger := (firstIndex$(Array MachineInteger)) .. ((firstIndex$(Array MachineInteger)) + machine prev(derivationSymbolsCount$DVARS));

	    ( a: DPR ): ( DPR, Set DPR ) +-> {
		ground? a => ( a, empty );
		for variableA in variables a | variableA >= mainVariableB repeat
		{
		    local coeffA : DPR;
		    local coeffB : DPR;
		    local coeffGcd : DPR;
		    import from Partial DPR;

		    if properDerivative?( variableA, mainVariableB ) then
		    { 
			local orderDifference: Array Integer := new( machine( derivationSymbolsCount$DVARS ), 0 );

			for elementOrderA in order variableA
			for elementOrderB in orderB 
			for elementIdx in orderSegment repeat 
			{
			    assert( elementOrderA >= elementOrderB );
			    orderDifference.elementIdx := elementOrderA - elementOrderB;
			}
			local diffB := differentiate( b, orderDifference );
			coeffB := - quotient( a, mainVariable diffB );
			coeffA := separantB;
			coeffGcd := gcd( coeffA, coeffB );
			assert( ~ failed?  exactQuotient( coeffA, coeffGcd ) );
			coeffA := retract exactQuotient( coeffA, coeffGcd );
			assert( ~ failed?  exactQuotient( coeffB, coeffGcd ) );
			coeffB := retract exactQuotient( coeffB, coeffGcd );
			return ( coeffA * a + coeffB * diffB, [ coeffA, coeffB ] );
		    } else if variableA = mainVariableB and degree( a, variableA ) >= degreeMainVariableB  then {
			coeffB := - divideByMainVariableBWithDegreeFunc a;
#if GCDVERSION
			coeffA := initialB;
			coeffGcd := gcd( coeffA, coeffB );
			assert( ~ failed?  exactQuotient( coeffA, coeffGcd ) );
			coeffA := retract exactQuotient( coeffA, coeffGcd );
			assert( ~ failed?  exactQuotient( coeffB, coeffGcd ) );
			coeffB := retract exactQuotient( coeffB, coeffGcd );
			return ( coeffA * a + coeffB * b, [ coeffA, coeffB ] );
#else
			return ( initialB * a + coeffB * b, [ initialB, coeffB ] ) ;
#endif			
		    }
		}
		( a, empty );
	    }
	}
    } else {
        reduceStep( b: DPR ): DPR -> ( DPR, Set DPR ) == {
	    zero? b => ( a: DPR ): ( DPR, Set DPR ) +-> { ( a, empty ); };
	    ground? b => (
	      import from DFLD;
	      invB := inv leadingCoefficient b;
	      ( a: DPR ): ( DPR, Set DPR ) +-> { 
		  zero? a => ( 0, empty );
		  ( 0, [ - invB*a ] );
	      }

	    );

	    import from Integer;
	    import from MachineInteger;
	    import from List DVARS;
	    import from DVARS;
	    assert( ~ ground? b );
	    local mainVariableB := mainVariable b;
	    local orderB := order mainVariableB;
	    local degreeMainVariableB := degree( b, mainVariable b );
	    local mainVariableBWithDegree := term( 1$DFLD, mainVariableB, degreeMainVariableB );
	    local divideByMainVariableBWithDegreeFunc := quotientBy( mainVariableB, degreeMainVariableB );
	    local separantB := separant b;
	    local initialB := initial b;

      	    assert( 0$Integer <= (derivationSymbolsCount$DVARS) );
      	    assert( (derivationSymbolsCount$DVARS) <= max$MachineInteger::Integer);
	    local orderSegment: IntegerSegment MachineInteger := (firstIndex$(Array MachineInteger)) .. ((firstIndex$(Array MachineInteger)) + machine prev(derivationSymbolsCount$DVARS));

	    ( a: DPR ): ( DPR, Set DPR ) +-> {
		ground? a => ( a, empty );
		for variableA in variables a | variableA >= mainVariableB repeat
		{
		    local coeff : DPR;

		    if properDerivative?( variableA, mainVariableB ) then
		    { 
			local orderDifference: Array Integer := new( machine( derivationSymbolsCount$DVARS ), 0 );

			for elementOrderA in order variableA
			for elementOrderB in orderB 
			for elementIdx in orderSegment repeat 
			{
			    assert( elementOrderA >= elementOrderB );
			    orderDifference.elementIdx := elementOrderA - elementOrderB;
			}
			local diffB := differentiate( b, orderDifference );
			coeff := - quotient( a, mainVariable diffB );
			return ( separantB * a + coeff * diffB, [ separantB, coeff ] );
		    } else if variableA = mainVariableB and degree( a, variableA ) >= degreeMainVariableB  then {
			coeff := - divideByMainVariableBWithDegreeFunc a;
			return ( initialB * a + coeff * b, [ initialB, coeff ] ) ;
		    }
		}
		( a, empty );
	    }
	}
    }

    -------------------------------------------

    if DVARS has EliminationOrderedDifferentialVariableType( VARS ) then
    {
        -- for elimination ordered DVARS
	reduceBy( as: AS ): ( DPR -> ( DPR, Set DPR ) ) == {
	    import from Integer;
	    import from MachineInteger;
	    import from DVARS;
	    import from DPR;
	    import from List DVARS;
	    import from Array List DVARS;
	    import from Array IntegerSegment MachineInteger;
	    import from List Integer;
	    import from Array List Integer;
	    import from List ( DPR -> ( DPR, Set DPR ) );
	    import from Array List ( DPR -> ( DPR, Set DPR ) );
            empty? as => ( a: DPR ): ( DPR, Set DPR ) +-> { ( copy a, empty ) };
	    contradictory? as => {
		assert( # as = 1 ); 
		reductionFunction: DPR -> ( DPR, Set DPR ) := reduceBy(as.(firstIndex$AS));
		( a: DPR ): ( DPR, Set DPR ) +-> { 
		    reductionFunction(a); 
		};
	    };

	    -- this code heavily relies on the fact, that Arrays are 0-indexed,
	    -- so better check this once.
	    assert( zero? (firstIndex$(Array List Integer)) );	    
	    assert( coerce (#$VARS) < max$MachineInteger::Integer);
	    local maxIdx: MachineInteger := #$VARS;
	    local arraySlots := next maxIdx;

	    local mainVarsPerClass : Array List DVARS := new( arraySlots, empty );
	    local degreeMainVarsPerClass : Array List Integer := new( arraySlots, empty );
	    local reduceStepsPerClass : Array List ( DPR -> ( DPR, Set DPR ) ) := new( arraySlots, empty );

	    for elementAs in as repeat 
	    {
		local mainVariableElementAs := mainVariable elementAs;
		local classMVElementAs := machine class mainVariableElementAs;
		mainVarsPerClass.classMVElementAs := insert!( mainVariableElementAs, mainVarsPerClass.classMVElementAs );
		degreeMainVarsPerClass.classMVElementAs := insert!( degree( elementAs, mainVariableElementAs ), degreeMainVarsPerClass.classMVElementAs );
		reduceStepsPerClass.classMVElementAs := insert!( reduceStep elementAs, reduceStepsPerClass.classMVElementAs );
	    }

	    local idxSegmentPerClass : Array IntegerSegment MachineInteger := new( arraySlots );
	    for mainVarList in mainVarsPerClass for idx in 0 .. maxIdx repeat 
	    {
		idxSegmentPerClass.idx :=  (firstIndex$(List DVARS))..(firstIndex$(List DVARS)) +  prev # mainVarList;
	    }

	    return (
	      ( a: DPR ): ( DPR, Set DPR ) +-> {
		  local resultPoly := copy a;	     
		  local resultSat : Set DPR := empty;
		  local notReducedInThisStep? := false;
		  local skipClassesAbove: Integer := coerce maxIdx;
		  notReducedInThisStep? := false;

		  while ~ notReducedInThisStep? repeat 
		  {			
                      notReducedInThisStep? := true;
		      variablesResult := variables resultPoly;

		      while ~ empty? variablesResult and skipClassesAbove < class( first variablesResult ) repeat
		      {
			  variablesResult := rest variablesResult;
		      }

		      for varRes in variablesResult while notReducedInThisStep? repeat
		      { 

			  local clsIdx := machine class varRes;

			  for mainVarsElementAs in mainVarsPerClass.clsIdx for idx in idxSegmentPerClass.clsIdx while notReducedInThisStep? repeat
			  {
			      if properDerivative?( varRes, mainVarsElementAs ) or (varRes = mainVarsElementAs and degree( resultPoly, varRes ) >= degreeMainVarsPerClass.clsIdx.idx) then
			      {
				  local stepSat : Set DPR;
				  ( resultPoly, stepSat ) := (reduceStepsPerClass.clsIdx.idx) resultPoly;
				  resultSat := union!( resultSat, stepSat );
				  notReducedInThisStep? := false;
				  skipClassesAbove := coerce clsIdx;
			      }
			  }	

		      }		 
		  }	     
		  ( resultPoly, resultSat );
	      }
	    )
	}
    } else {
        -- for DVARS, that are not elimination ordered
	reduceBy( as: AS ): ( DPR -> ( DPR, Set DPR ) ) == {
	    import from Integer;
	    import from MachineInteger;
	    import from DVARS;
	    import from DPR;
	    import from List DVARS;
	    import from Array List DVARS;
	    import from Array IntegerSegment MachineInteger;
	    import from List Integer;
	    import from Array List Integer;
	    import from List ( DPR -> ( DPR, Set DPR ) );
	    import from Array List ( DPR -> ( DPR, Set DPR ) );
            empty? as => ( a: DPR ): ( DPR, Set DPR ) +-> { ( copy a, empty ) };
	    contradictory? as => {
		assert( # as = 1 ); 
		reductionFunction: DPR -> ( DPR, Set DPR ) := reduceBy(as.(firstIndex$AS));
		( a: DPR ): ( DPR, Set DPR ) +-> { reductionFunction(a); };
	    };

	    -- this code heavily relies on the fact, that Arrays are 0-indexed,
	    -- so better check this once.
	    assert( zero? (firstIndex$(Array List Integer)) );	    
	    assert( coerce (#$VARS) < max$MachineInteger::Integer);
	    local maxIdx: MachineInteger := #$VARS;
	    local arraySlots := next maxIdx;

	    local mainVarsPerClass : Array List DVARS := new( arraySlots, empty );
	    local degreeMainVarsPerClass : Array List Integer := new( arraySlots, empty );
	    local reduceStepsPerClass : Array List ( DPR -> ( DPR, Set DPR ) ) := new( arraySlots, empty );

	    for elementAs in as repeat 
	    {
		local mainVariableElementAs := mainVariable elementAs;
		local classMVElementAs := machine class mainVariableElementAs;
		mainVarsPerClass.classMVElementAs := insert!( mainVariableElementAs, mainVarsPerClass.classMVElementAs );
		degreeMainVarsPerClass.classMVElementAs := insert!( degree( elementAs, mainVariableElementAs ), degreeMainVarsPerClass.classMVElementAs );
		reduceStepsPerClass.classMVElementAs := insert!( reduceStep elementAs, reduceStepsPerClass.classMVElementAs );
	    }

	    local idxSegmentPerClass : Array IntegerSegment MachineInteger := new( arraySlots );
	    for mainVarList in mainVarsPerClass for idx in 0 .. maxIdx repeat 
	    {
		idxSegmentPerClass.idx :=  (firstIndex$(List DVARS))..(firstIndex$(List DVARS)) +  prev # mainVarList;
	    }

	    return (
	      ( a: DPR ): ( DPR, Set DPR ) +-> {
		  local resultPoly := copy a;	     
		  local resultSat : Set DPR := empty;
		  local notReducedInThisStep? := false;
		  notReducedInThisStep? := false;

		  while ~ notReducedInThisStep? repeat 
		  {			
                      notReducedInThisStep? := true;
		      variablesResult := variables resultPoly;

		      for varRes in variablesResult while notReducedInThisStep? repeat
		      { 

			  local clsIdx := machine class varRes;

			  for mainVarsElementAs in mainVarsPerClass.clsIdx for idx in idxSegmentPerClass.clsIdx while notReducedInThisStep? repeat
			  {
			      if properDerivative?( varRes, mainVarsElementAs ) or (varRes = mainVarsElementAs and degree( resultPoly, varRes ) >= degreeMainVarsPerClass.clsIdx.idx) then
			      {
				  local stepSat: Set DPR;
				  ( resultPoly, stepSat ) := (reduceStepsPerClass.clsIdx.idx) resultPoly;
				  resultSat := union!( resultSat, stepSat );
				  notReducedInThisStep? := false;
			      }
			  }	
		      }		 
		  }	     
		  ( resultPoly, resultSat );
	      }
	    )
	}
    }

    -------------------------------------------

    if DPR has GcdDomain then
    {
	consequences( a: DPR, b: DPR ): ( List DPR, Set DPR ) == {
	    import from Integer;
	    import from MachineInteger;
	    import from DVARS;

	    ground? a or ground? b =>( [ 0 ], empty$(Set DPR) );

	    local mainVariableA := mainVariable a;
	    local mainVariableB := mainVariable b;

	    class mainVariableA ~= class mainVariableB =>( [ 0 ], empty$(Set DPR) );

      	    assert( 0$Integer <= (derivationSymbolsCount$DVARS) );
      	    assert( (derivationSymbolsCount$DVARS) <= max$MachineInteger::Integer);

	    local psi : Array Integer := new( machine derivationSymbolsCount, 0 );
	    local phi : Array Integer := new( machine derivationSymbolsCount, 0 );
	    local orderA := order mainVariableA;
	    local orderB := order mainVariableB;

	    for idx in firstIndex$(Array Integer) .. firstIndex$(Array Integer) + prev machine derivationSymbolsCount 
	    repeat
	    {
		local elementOrderA := orderA.idx;
		local elementOrderB := orderB.idx;
		if elementOrderA > elementOrderB then
		{ 
		    phi . idx := elementOrderA - elementOrderB;
		} else if elementOrderA < elementOrderB then {
		    psi . idx := elementOrderB - elementOrderA;
		}
	    }

	    local negSepA := - separant a;
	    local sepB := separant b;
	    local sepGcd := gcd( negSepA, sepB );
	    import from Partial DPR;
	    assert( ~ failed? exactQuotient( negSepA, sepGcd ));
	    negSepA := retract exactQuotient( negSepA, sepGcd );
	    assert( ~ failed? exactQuotient( sepB, sepGcd ));
	    sepB := retract exactQuotient( sepB, sepGcd );

            --the version with "*" and "+" is more efficient than the version with "add!" and "times"
	    --( add!( times!( sepB, differentiate( a, psi ) ), times!( negSepA,  differentiate( b, phi ) ) ), [ negSepA, sepB ] );
	    ( [ sepB * differentiate( a, psi ) + negSepA * differentiate( b, phi ) ], [ negSepA, sepB ] );
	}
    } else {
	consequences( a: DPR, b: DPR ): ( List DPR, Set DPR ) == {
	    import from Integer;
	    import from MachineInteger;
	    import from DVARS;

	    ground? a or ground? b =>( [ 0 ], empty$(Set DPR) );

	    local mainVariableA := mainVariable a;
	    local mainVariableB := mainVariable b;

	    class mainVariableA ~= class mainVariableB =>( [ 0 ], empty$(Set DPR) );

      	    assert( 0$Integer <= (derivationSymbolsCount$DVARS) );
      	    assert( (derivationSymbolsCount$DVARS) <= max$MachineInteger::Integer);

	    local psi : Array Integer := new( machine derivationSymbolsCount, 0 );
	    local phi : Array Integer := new( machine derivationSymbolsCount, 0 );
	    local orderA := order mainVariable a;
	    local orderB := order mainVariable b;
	    for idx in firstIndex$(Array Integer) .. firstIndex$(Array Integer) + prev machine derivationSymbolsCount repeat
	    {
		local elementOrderA := orderA.idx;
		local elementOrderB := orderB.idx;
		if elementOrderA > elementOrderB then
		{ 
		    phi . idx := elementOrderA - elementOrderB;
		} else if elementOrderA < elementOrderB then {
		    psi . idx := elementOrderB - elementOrderA;
		}
	    }

	    local negSepA := - separant a;
	    local sepB := separant b;

            --the version with "*" and "+" is more efficient than the version with "add!" and "times"
	    --( add!( times!( sepB, differentiate( a, psi ) ), times!( negSepA,  differentiate( b, phi ) ) ), [ negSepA, sepB ] );
	    ( [ sepB * differentiate( a, psi ) + negSepA * differentiate( b, phi ) ], [ negSepA, sepB ] );
	}
    }    
    -------------------------------------------

}
