-------------------------------------------------------------------------
--
-- cs_prem.as
--
-------------------------------------------------------------------------

#include "charset.as"

macro AS == AutoreducedSet( T, % );

+++\begin{addescription}{computes pseudo remainders}
+++Let $p, q, \text{ and } r$ be elements of \adcode{T}. $p$ \emph{is reduced with respect to} $q$ if and only if 
+++\begin{itemize}
+++\item $q$ is zero,
+++\item $q$ is a non zero constant and $p$ is zero, or
+++\item $q$ is not a constant and the degree of $p$ with respect to the main indeterminate of $q$ is smaller then the degree of $q$ with respect to its main indeterminate.
+++\end{itemize}
+++
+++If $q$ \emph{reduces} $p$ to $r$, one of the following conditions has to hold.
+++\begin{itemize}
+++\item $q$ is zero and $p$ = $r$.
+++\item $q$ is a non zero constant and $r$ is zero.
+++\item $q$ is not a constant, $r$ is reduced with respect to $q$ such that
+++$$a p =  r \text{ mod } (q),$$
+++where $( q )$ denotes the ideal generated by $q$ and $a$ is a power of the coefficient of $q$ with respect to $q$'s main indeterminate to its highest degree.
+++\end{itemize}
+++\end{addescription}
PseudoRemainderReductionTools(
  R : with {
      Ring;
      CharacteristicZero;
  },
  VARS: VariableType,
  T   : PolynomialRing0( R, VARS )
) : with {

    ReductionType T;

} == add {

    import from T;

    -------------------------------------------

    reducedBy?( b: T ): T -> Boolean == {

	zero? b => ( a: T ): Boolean +-> { true; };
	ground? b => ( a: T ): Boolean +-> { zero? a; };

	local mainVar := mainVariable b;
	local degBMainVar := degree( b, mainVar );
	import from Integer;
	( a: T ): Boolean +-> {
	    degree( a, mainVar ) < degBMainVar;
	}
    }

    -------------------------------------------

    reduceBy( b: T ): T -> T == {
	import from R;
	import from T;	
	zero? b =>  ( a: T ): T +-> { a };
	ground? b => ( a: T ): T +-> { 0 };

	import from Integer;
	local mainVar := mainVariable b;
	local degBMainVar := degree( b, mainVar );

	( a: T ): T +-> {
	    local ret := copy a;
	    local degRetMainVar := degree( ret, mainVar );
	    degRetMainVar < degBMainVar => ret;

	    local lcB := coefficient( b, mainVar, degBMainVar );
	    local degDiff: MachineInteger := machine( degRetMainVar - degBMainVar );
	    local mainVarPower: Array T := new next degDiff;
	    local mainVarT: T := mainVar::T;
	    mainVarPower . (firstIndex$(Array T)) := 1;
	    for idx in (firstIndex$(Array T)) + 1 .. (firstIndex$(Array T)) + degDiff repeat
	    {
		mainVarPower . idx := mainVarT * mainVarPower . (prev idx);
	    }	

	    while ( degRetMainVar >= degBMainVar ) repeat 
	    {
		local negLcRet := - coefficient( ret, mainVar, degRetMainVar );
		ret := add!( times!( ret, lcB ), times!( times!( negLcRet, b ), mainVarPower . ( (firstIndex$(Array T)) + machine ( degRetMainVar - degBMainVar ) ) ) );
		degRetMainVar := degree( ret, mainVar );
	    }
	    ret;
	}
    }

    -------------------------------------------


}
